<!--
 * @Description: 
 * @Author: 张泽雨
 * @Date: 2024-03-14 13:02:44
 * @LastEditors: 张泽雨
 * @LastEditTime: 2024-03-14 14:01:02
 * @FilePath: \my-study\http常用知识总结\02.html
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>http知识总结</title>
  </head>
  <body>
    <script>
      /**
       *HTTP 请求结构
      请求行
      请求方法: GET、POST、PUT、DELETE、HEAD、OPTIONS 等
      请求 URL: 包括协议、主机名、端口号、路径、查询字符串等
      HTTP 版本: 如 HTTP/1.1、HTTP/2.0 等
      请求头

      通用头: 如 Host、User-Agent、Accept、Accept-Encoding 等
      请求头: 如 Accept、Accept-Encoding、Connection、Cookie、Referer 等
      实体头: 如 Content-Type、Content-Length 等
      请求体

      对于 POST、PUT 等请求方法,请求体用于传输数据
      HTTP 响应结构

      状态行

      HTTP 版本: 如 HTTP/1.1、HTTP/2.0 等
      状态码: 如 200 OK、404 Not Found、500 Internal Server Error 等
      状态码描述: 一个简短的状态码说明
      响应头

      通用头: 如 Date、Connection、Server 等
      响应头: 如 Content-Type、Content-Length、Cache-Control 等
      实体头: 如 Content-Encoding、ETag、Expires 等
      响应体

      服务器返回给客户端的实际数据内容
      状态码

      1xx 信息状态码: 接收的请求正在处理
      2xx 成功状态码: 请求正常处理完毕
      200 OK: 请求成功
      204 No Content: 请求成功,但响应没有实体
      206 Partial Content: 服务器已经成功处理了部分 GET 请求
      3xx 重定向状态码: 需要进行附加操作以完成请求
      301 Moved Permanently: 永久重定向
      302 Found: 临时重定向
      304 Not Modified: 协商缓存命中,可使用缓存
      4xx 客户端错误状态码: 服务器无法处理请求
      400 Bad Request: 请求语法错误
      401 Unauthorized: 需要身份认证
      403 Forbidden: 服务器拒绝请求
      404 Not Found: 未找到请求资源
      5xx 服务器错误状态码: 服务器处理请求出错
      500 Internal Server Error: 服务器内部错误
      502 Bad Gateway: 网关错误
      503 Service Unavailable: 服务暂时过载或维护
      请求头和响应头

      Content-Type: 实体主体的媒体类型
      Content-Length: 实体主体的长度
      Accept: 客户端可接受的响应类型
      Accept-Encoding: 客户端可接受的编码格式
      User-Agent: 发起请求的用户代理标识
      Server: 服务器名称
      Referer: 请求来源地址
      Cookie: 客户端向服务器传递的 Cookie 数据
      Set-Cookie: 服务器向客户端设置的 Cookie 数据
      Cache-Control: 控制缓存机制
      Expires: 资源过期时间
      ETag: 资源唯一标识
      Last-Modified: 资源最后修改时间
      Connection: 连接管理
      Transfer-Encoding: 传输编码方式
      Upgrade: 升级 HTTP 协议版本
      通过以上内容,我们详细介绍了 HTTP 请求和响应的结构、状态码、请求头和响应头等知识点。
      HTTP 作为 Web 的基础协议,
      理解其请求和响应的细节对于开发高性能 Web 应用至关重要。
      这些知识点涵盖了广泛的内容,对于提高 Web 开发能力很有帮助
       */

      /**
       * HTTP/1.1、HTTP/2 和 HTTP/3 是 HTTP 协议的三个主要版本,它们在性能、功能和底层实现上有着显著的差异,
       * 主要区别总结如下:
              HTTP/1.1

              基于文本的协议格式,每次请求响应都需要进行多次 TCP 连接,效率较低。
              请求管道化,多个请求需按顺序发送,并无法并行处理。
              头部未经压缩,请求和响应的首部冗余较大。
              无法主动推送资源,依赖客户端发起请求。
              HTTP/2

              采用二进制协议格式,更加高效紧凑。
              单个 TCP 连接可并行多路请求和响应,提高传输效率。
              头部压缩,减少了首部的冗余数据。
              服务端可主动推送资源,减少多次请求的开销。
              支持服务端推送数据和流量控制。
              HTTP/3

              基于 QUIC(快速 UDP 互联网连接)协议,底层通过 UDP 进行传输。
              内置加密,不再需要额外的 TLS 加密。
              连接建立更快,减少了传统 TCP+TLS 的多次握手过程。
              改进了拥塞控制和丢包重传机制,更好地适应移动端网络。
              与 HTTP/2 几乎相同的语义,但在传输层有很大差异。
              三者之间的性能对比:

              连接开销
              HTTP/1.1 每次请求都需要重新建立 TCP 连接,开销较大。HTTP/2 通过单一持久连接可并发多个请求,HTTP/3 
              基于 UDP 更节约连接开销。

              头部压缩
              HTTP/1.1 头部未经压缩,HTTP/2 采用高效的头部压缩编码,HTTP/3 继承了同样的压缩算法。

              多路复用
              HTTP/1.1 不支持多路复用,HTTP/2 和 HTTP/3 支持在单一连接上多路复用。

              安全性
              HTTP/1.1 需要单独启用 TLS,HTTP/2 可选启用 TLS,而 HTTP/3 内置加密功能更安全。

              性能提升比较
              相较 HTTP/1.1,HTTP/2 可提升 50%~70% 的性能,而 HTTP/3 对于移动端网络环境可提升更大的性能。
              总的来说,HTTP/2 和 HTTP/3 是对 HTTP/1.1 的重大改进,旨在提高传输性能、减少延迟,为应用提供更快速、
              更可靠的体验。HTTP/3 在移动端网络环境下具有一定的优势,但浏览器和服务端的支持程度也需要考虑。
              未来 HTTP/3 会逐步替代 HTTP/2,成为主流的 Web 传输协议
       * 
       * */

      /**
        * 好的,我将详细讲解管道化、多路复用、头部压缩和 UDP 传输这几个重要的概念。

            管道化(HTTP/1.1)
            管道化是 HTTP/1.1 中的一项优化技术,它允许在同一个 TCP 连接上并行发出多个请求,
            而不需要等待响应返回再发送下一个请求。这样可以减少连接开销,降低传输延迟。

            但管道化也存在一些缺陷:

            请求之间是有序的,后面的请求必须等待前面的请求完成才能获得响应。
            服务器处理请求的顺序不可预知,可能会发生队头阻塞。
            对 HEAD 和其他无实体响应的请求,服务器必须关闭连接。
            多路复用(HTTP/2、HTTP/3)

            多路复用技术允许在单个 TCP 或 UDP 连接上同时发送多个请求和响应,且无需按序。这解决了 HTTP/1.1 
            中的队头阻塞问题,显著提高了性能。

            多路复用的优势:

            无序响应,可并行处理多个请求和响应。
            共享单一连接,减少连接开销和延迟。
            支持流量控制和优先级控制。
            头部压缩(HTTP/2、HTTP/3)

            HTTP 头部通常比数据体积更大,而且存在大量冗余信息。HTTP/2 和 HTTP/3 使用了高效的压缩算法(HPACK)来压缩头部,
            从而减小传输数据量,提高传输效率。

            压缩步骤:

            在客户端和服务器端维护一个共享的字典,存储常见的头部字段。
            使用索引静态或动态替换字典中的头部字段。
            对剩余头部字段进行哈夫曼编码压缩。
            UDP 传输(HTTP/3)

            HTTP/3 基于 QUIC 协议,采用了 UDP 作为底层传输层协议,而非 TCP。

            使用 UDP 的优势:

            减少了 TCP 连接建立的开销,加快连接建立速度。
            内置连接迁移、重传和拥塞控制机制,提升可靠性。
            独立于 TCP,不受队头阻塞等 TCP 缺陷的影响。
            默认启用了安全传输加密,无需额外的 TLS 开销。
            当然 UDP 也有一些缺点,如不能直接穿透防火墙、可靠性依赖上层协议等,这也是以往 HTTP 协议选择 TCP 的原因。
            但 QUIC 协议很好地解决了这些问题。

             综上所述,管道化、多路复用、头部压缩和 UDP 传输都是 HTTP 协议为了提升传输性能而采用的核心技术手段。
            通过消除队头阻塞、减少连接开销、压缩数据等措施,HTTP/2 和 HTTP/3 大幅提升了 Web 应用的性能和用户体验。
       */

      /**
        * UDP 和 TCP 是两种重要的传输层协议,在通信机制、可靠性、连接方式等方面存在显著差异。我们一起来详细对比一下:

              连接方式

              TCP 是面向连接的协议,传输数据前需要三次握手建立连接。
              UDP 是无连接的协议,不需要建立连接就能直接发送数据。
              可靠性

              TCP 提供可靠的数据传输服务,有序传输、重传控制、流量控制、拥塞控制等机制保证数据完整性。
              UDP 是不可靠的传输协议,不保证数据的完整性,数据可能丢失、重复、乱序。
              传输方式

              TCP 是面向字节流的协议,发送数据时将其看作一个无结构的字节流。
              UDP 是面向报文的协议,发送数据时会给数据添加源端口和目的端口号,这样就构成了数据报文段。
              首部开销

              TCP 首部较大,有 20-60 字节不等。
              UDP 首部只有 8 字节。
              传输速度

              TCP 需要先建立连接、保证可靠传输,导致传输速度比 UDP 慢。
              UDP 不需要建立连接、不存在拥塞控制等机制,传输速度较快。
              应用场景

              TCP 适用于对可靠性要求较高的场景,如文件传输、远程登录、HTTP 等。
              UDP 适用于对实时性要求较高的场景,如视频直播、在线游戏、DNS 等。
              常见特性对比

              特性	TCP	UDP
              连接方式	面向连接	无连接
              可靠性	可靠	不可靠
              传输方式	字节流	报文段
              首部开销	较大	较小
              顺序控制	有	无
              重传机制	有	无
              流量控制	有	无
              拥塞控制	有	无
              总的来说，TCP 提供了一种可靠、有序、面向字节流的通信服务，适用于对可靠性要求较高的应用场景。
              而 UDP 则提供了一种不可靠、无序、面向报文的通信服务，适用于对实时性要求较高的应用场景。
              在设计网络应用时，需要根据实际需求来选择合适的传输层协议。
       */

      /**
        * HTTP 认证
        HTTP 认证是指在客户端与服务器传输数据前,服务器需要验证客户端的身份,以确保数据的安全性和保密性。常见的 HTTP 认证方式有:

        基本认证(Basic Authentication)
        基本认证是最简单的认证方式。客户端将用户名和密码按照特定格式(username:password)编码后的字符串放在 Authorization 头域中发送给服务器。
        这种方式虽然简单,但是有安全隐患,容易被窃听。

        Digest 认证(Digest Access Authentication)
        Digest 认证是一种安全性更高的认证方式。它的认证过程涉及到加密,不会直接在网络上传输明文密码。客户端会将密码和其他信息计算出一个摘要,
        发送给服务器。
        服务器也通过相同的算法计算摘要,比较两者是否一致来进行身份验证。

        HTTP 授权

        HTTP 授权是指服务器允许或拒绝客户端对特定资源的访问,控制权限的过程。常见的授权使用场景如限制付费用户访问、防止修改他人数据等。
        授权通常是在认证基础之上进行的。

        OAuth 2.0 协议

        OAuth 2.0 是一种业界标准的授权协议,它为第三方应用分配有限的权限来访问用户数据提供了安全机制,而不需要直接获取用户的账号密码。
        它包括以下几个重要的概念:

        资源拥有者(Resource Owner):拥有受保护资源的实体,通常是最终用户。

        客户端(Client): 想要获取资源的第三方应用。

        授权服务器(Authorization Server): 负责管理认证和授权的服务器。

        资源服务器(Resource Server): 存储受保护资源的服务器。

        OAuth 2.0 的运作流程大致如下:

        客户端向资源拥有者申请授权。
        资源拥有者同意发放授权凭证(授权码或访问令牌)给客户端。
        客户端使用授权凭证向授权服务器请求访问令牌。
        授权服务器验证授权凭证,颁发访问令牌给客户端。
        客户端使用访问令牌向资源服务器请求受保护的资源。
        OAuth 2.0 提供了四种授权模式:授权码模式、简化模式、密码模式和客户端模式。其优势包括简单、分离性好、安全性强等。
        它广泛应用于第三方登录、云服务授权等场景。
        总之,HTTP 认证用于验证客户端身份,授权用于控制对资源的访问权限。两者结合可以保护系统的安全性。
        而 OAuth 2.0 则提供了一种标准化、安全的授权机制,让客户端可以访问受保护资源但无需直接获取账号密码,
        极大提高了系统的安全性。理解这些概念对构建安全的 Web 应用至关重要。
        * 
        * 
        * 
       */
      /**
       * HTTP 本身是一种无状态协议,即服务器无法判断两个请求是否来自同一客户端。但很多 Web 应用都需要跟踪用户的状态,如用户身份、购物车等。为此,HTTP 状态管理应运而生。我将详细讲解 HTTP 会话、Session、Cookie 以及状态跟踪的相关概念。

HTTP 会话

HTTP 会话(Session)是指客户端与服务器进行多次请求和响应的过程。在这个过程中,服务器需要识别是否来自同一客户端,以维护正确的状态信息。会话可以基于 Cookie 或者其他机制来实现。

Cookie

Cookie 是服务器发送到浏览器并保存在客户端的一小段数据。它由一个名/值对组成,且有作用域、有效期等属性。浏览器在发送请求时会自动携带 Cookie 到服务器。

Cookie 一般用于以下几个方面:

会话管理: 通过 Cookie 标识同一客户端的请求,实现会话跟踪。
个性化处理: 服务器可以根据 Cookie 信息为不同客户端提供个性化内容。
跟踪统计: 通过 Cookie 识别客户端身份,进行访问统计。
Session

Session 是服务器端用来跟踪客户端状态的机制。当客户端首次请求时,服务器会创建一个 Session 对象,并为其分配一个唯一的 ID(Session ID)。之后客户端的请求都会携带这个 Session ID,服务器通过映射得到对应的 Session 对象,从而跟踪客户端状态。

Session 常用于存储如下信息:

用户身份信息(登录状态)
购物车内容
页面访问次数等统计数据
Session 可以存储在服务器内存、数据库或者缓存服务器中。为避免内存溢出或网络拥塞,通常需要对 Session 进行有效期管理。

状态跟踪实现

客户端和服务器可以通过多种方式实现状态跟踪,常见的有:

Cookie 方式:服务器通过设置响应头 Set-Cookie 在客户端写入 Cookie,客户端请求时通过 Cookie 请求头将 Cookie 发送给服务器。这也是目前最常用的方式。

URL 重写方式:将会话状态信息编码到 URL 中,如 http://example.com/page.html;jsessionid=123456。

隐藏表单字段方式:将状态信息存储在 <input type="hidden"> 的值中,每次请求都携带这些表单字段。

HTTP 头扩展方式:将状态信息存储在 HTTP 自定义头部字段中。

在前端开发中,通常不需要直接操作 Session,而是通过使用 Cookie 或 URL 重写方式与服务器交互来维护状态。例如，基于 Cookie 的身份认证常见的做法是:

用户登录时,服务器设置 Session,并通过 Set-Cookie 响应头将 Session ID 写入客户端 Cookie。
之后的每次请求都会通过 Cookie 请求头携带 Session ID。
服务器根据 Session ID 找到对应的 Session 对象,判断用户的登录状态。
综上所述,Session 和 Cookie 共同实现了 HTTP 会话状态管理的功能。Session 存储在服务器端,用于跟踪客户端状态;
而 Cookie 则存储在客户端,作为识别同一客户端的凭证。通过 Cookie 和 Session 的巧妙结合,Web 应用实现了类似连接的功能,
使得无状态 HTTP 协议也能交互式地为用户提供服务。
      */
    </script>
  </body>
</html>
