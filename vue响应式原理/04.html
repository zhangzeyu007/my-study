<!--
 * @Description: 
 * @Author: 张泽雨
 * @Date: 2024-03-15 14:44:48
 * @LastEditors: 张泽雨
 * @LastEditTime: 2024-03-15 16:10:17
 * @FilePath: \my-study\vue响应式原理\04.html
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>vue3.0 响应式原理</title>
  </head>
  <body>
    <script>
      /**
       * Vue 在渲染过程中使用了虚拟 DOM (Virtual DOM) 的概念,它是一个用 JavaScript 对象来模拟真实 DOM 树的数据结构。在进行页面更新时,
       * Vue 会比较新旧两个虚拟 DOM 树的差异,然后只更新有差异的部分,这个比较的过程就是 Vue 的 diff 算法。

        Vue 的 diff 算法主要遵循以下几个原则:

            1. **只比较同一层级的节点**

            Vue 在进行虚拟 DOM 比较时,只会比较同一层级的节点。如果节点在不同层级上,Vue 则直接删除旧节点,重新创建新节点。
            这是因为在跨层级移动节点的代价是很高的,所以 Vue 选择牺牲一些性能,以获得更好的用户体验。

            2. **在比较同一层级的节点时,Vue 会先比较节点的类型**

            如果两个节点的类型不同,Vue 会直接删除旧节点,创建新节点。如果两个节点的类型相同,则继续进行后续的比较操作。

            3. **对于同一类型的节点,Vue 会比较它们的属性**

            Vue 会比较两个节点的属性,如果有不同,则更新该属性。如果属性相同,则继续比较子节点。

            4. **对于子节点,Vue 也是递归地进行比较**

            Vue 会采用同样的策略比较子节点,只比较同一层级的子节点,比较每个子节点的类型、属性等。

            5. **Vue 使用了几个优化策略来提高 diff 算法的性能**

            - **对于相同的节点,Vue 会尽量复用已经渲染过的节点,而不是重新创建新的节点。**
            - **如果一个节点只是改变了文本内容,Vue 会直接更新该节点的文本内容,而不会删除重建整个节点。**
            - **Vue 会跟踪每个节点的身份,基于节点的 key 属性,以便在比较的时候更好地判断节点是否可以复用。**

            除了以上的策略,Vue 还采用了一些其他的技术来优化 diff 算法,比如对于静态节点的缓存等。

            总的来说,Vue 的 diff 算法是基于两个简单的假设:

            1. 相同的组件会生成相似的节点树。
            2. 组件的节点树中响应式数据的更新可以被高效地计算出来。

            基于这两个假设,Vue 的 diff 算法就是通过比较新旧虚拟 DOM 树的差异,只更新有差异的部分,从而提高了整体的渲染效率。

            当然,Vue 的 diff 算法也并非完美,在某些极端情况下,它可能会做一些低效或者不必要的更新操作。
            但就整体而言,Vue 的 diff 算法已经比较优秀了,能够在大部分情况下保证高效的渲染性能。
      */
      /**
      * diff 算法在比较新旧虚拟 DOM 时,会经历以下详细的过程:

1. **首先根据 Virtual DOM Tree 生成 Vnode 树**

在 Vue 中,每个 Virtual DOM 节点都会生成一个 Vnode 对象。Vnode 对象包含了节点的一些基本信息,如标签名、数据、子节点、键值等,
是对真实 DOM 节点的一个映射。

2. **当数据发生变化后,重新构造新的 Vnode 树**

当数据发生变化后,Vue 会根据新的数据,构建一个新的 Vnode 树。

3. **使用新旧 Vnode 树,孰徇一个 patch 函数并应用补丁**

在得到新旧两棵 Vnode 树后,Vue 会对比它们的差异。实现了如何获取差异的过程就是核心的 diff 算法。
这个过程被包括在 patch 函数里,它会根据两个 Vnode 树构建一个渲染 Web 页面所需的一系列操作的最小加载库。Vue 中的 diff 算法会遵循上述提到的5个原则。

4. **diff 算法的具体实现**

diff 算法的核心逻辑包括以下几个步骤:

**a. 首先检查新旧两个 Vnode 节点是否为相同节点,若不是,直接替换旧的节点。**

**b. 如果是相同节点,则检查是否是静态节点,若是,则直接跳过,不做任何操作。**

**c. 如果是文本节点,则比较文本内容是否发生变化,若变化了,则直接更新文本内容即可。**

**d. 如果是非文本节点,则比较属性是否发生变化,若发生变化,则直接更新属性即可。**

**e. 如果不是文本节点且属性没有变化,则比较子节点是否发生变化。**

这是最复杂的一步,diff 算法会在这一步进行深层的树形遍历,主要步骤为:

- 首先设置新旧两棵树的头尾指针
- 然后进入循环比对:
    - 比较 oldStartVNode 和 newStartVNode 是否是同一节点,是则 patch 当前节点,并将头指针向后移
    - 比较 oldEndVNode 和 newEndVNode 是否是同一节点,是则 patch 当前节点,并将尾指针向前移
    - 如果以上两种情况都不满足,则遍历 newVnode 列表,查找是否有与 oldStartVNode 相同的节点,如果有就 patch,没有则创建新节点插入
    - 如果遍历完 newVnode 都没有找到与 oldStartVNode 相同的节点,则说明是多余的节点,需要将 oldStartVNode 删除
    - 上述步骤循环执行,直到 oldVnode 或者 newVnode 列表被遍历完毕
- 如果 oldVnode 先遍历完(即 newVnode 还有剩余),则将剩余的节点批量插入到最后
- 如果 newVnode 先遍历完(即 oldVnode 还有剩余),则将剩余的旧节点批量删除
- 最后处理移动的节点

5. **在生成 patch 函数的过程中,Vue 会产生一系列需要执行的DOM操作,如节点的更新、插入、删除等,之后将这些操作统一执行在真实的DOM上。**

通过以上过程,Vue 的 diff 算法能够非常高效地找出需要更新的节点,并减少对真实 DOM 的操作,从而提高渲染性能。

需要注意的是,Vue 在比较新旧节点时,会跟踪每个节点的身份,基于节点的 key 属性,以便在比较的时候更好地判断节点是否可以复用。
所以在编写列表组件时,为节点设置唯一的 key 值是非常重要的一步。

总的来说,Vue 的 diff 算法非常复杂和高效,它通过提供各种优化策略,能够最大化地减少操作真实 DOM 的代价,从而提升渲染性能。
但同时,它也有一些限制和瓶颈,例如无法处理跨层级的节点移动等,这需要我们在编码时注意一些编码规范。
  */

      /*
     在你提到的这段描述中,"patch 当前节点"是指应用更新到真实 DOM 上。具体来说:

在 Vue 的 diff 算法中,通过比较新旧两个 VNode 树,找出需要更新的地方。当发现两个节点是相同节点时(比如都是同一个元素的 VNode),就会执行 "patch" 操作。

"patch" 操作的具体内容包括:

1. **如果是文本节点**:
   - 如果新旧文本不同,则更新文本内容。

2. **如果是元素节点**:
   - 如果新旧节点是相同元素,则进一步比较属性是否有变化。若有变化,则更新属性。
   - 然后比较子节点是否发生变化,根据 diff 算法找出需要更新的子节点,递归执行 patch 操作。

3. **如果新旧节点是不同的节点类型**:
   - 则删除旧节点,重新创建新节点并插入。

实际上,"patch 当前节点"本质上就是对比新旧两个 VNode,将变化的地方更新到真实 DOM 上。换句话说,就是将对应的 VNode 映射成真实的 DOM 操作执行。

这个过程是通过递归调用的方式,自顶向下逐层比较并更新 DOM。当递归到最底层的叶子节点时,如果发现只是文本变化,则直接更新文本内容;
如果节点完全不同,则直接替换整个节点。

所以,"patch 当前节点"可以理解为将当前节点的更新映射到真实 DOM 上,而非只是比较 VNode 的操作。
只有将变化映射到真实 DOM 上,页面的改动才能呈现出来。
     */

      /*
     在 Vue 的 diff 算法中,采用首尾指针先比较的方式,主要有以下几个好处:

1. **更高的元素复用率**

大部分情况下,对于同一层级的子节点进行前后添加/移除等操作更为常见,而非逆序操作。使用首尾指针的策略,可以更好地命中这种场景,
从而复用更多的节点,减少消耗。

2. **减少移动操作**

元素的移动操作相对较为耗费性能。采取首尾指针比较的策略,一方面能够命中元素工整的情况(不需要移动),
另一方面即使需要移动,由于只对相同节点进行比较,移动的元素也会更加靠近需要移动的位置,移动次数更少。

3. **提高了遍历效率**

相比于简单的遍历,首尾指针可以减少遍历次数。在最理想的情况下,只需要一次遍历即可完成比较,这极大提升了遍历效率。

4. **减少了对转换键算法的依赖**

如果直接遍历新旧两个完整的 VNode 列表,在发生节点互换位置的情况时,需要依赖一些更加复杂的算法(如 ****旧****转换键算法**)来定位新旧 VNode 的对应关系。
而采用首尾指针比较的策略,则可以有效避免这个问题,从而减少了算法的复杂度。

5. **代码实现简单**

首尾指针比较相对于其他一些更加复杂的最优化策略,具有实现简单的优点。这种实现方式足够高效,且可读性好,利于后期的维护。

总的来说,采用首尾指针比较策略,可以提高大多数场景下的元素复用率,减少不必要的移动操作,提升遍历效率,同时实现起来也较为简单。
因此,Vue 选择这种方式作为 diff 算法的优化策略。

当然,这种策略也不是万能的,在一些情况下(如节点为全逆序)可能会达不到最优的更新效果。Vue 的团队在性能和实现的复杂度之间进行了权衡,
并最终选择了这种相对简单且较为高效的策略。
     
     */

      /*
  Vue 3 在 diff 算法上相比 Vue 2 有一些优化和改进,主要体现在以下几个方面:

1. **静态提升(Static Node Hoisting)**

Vue 3 会在与 Vue 2 相同的静态节点上做启发式的静态提升优化, 从而跳过每次重新渲染最优化静态节点,只对作为动态节点的一小部分进行渲染。

这个优化可以通过将静态节点的渲染工作从渲染工作中剥离出来并缓存, 从而避免静态节点也重复地被创建。

2. **事件缓存**

在 Vue 3 中，事件监听器现在会被缓存在渲染函数的上下文中,默认情况下，会直接复用事件对象,避免了事件对象的反复创建和卸载,从而节省了性能开销。

3. **编译模型优化**

Vue 3 改用了更高效的模板编译模型,生成的渲染函数代码更加高效和更小。

编译模型的优化体现在以下几个方面:

- 更小的渲染函数体积:通过全新的模板引擎重写,生成更小的渲染函数体积。
- 更好的源码缓存:在生成渲染函数时,会同时生成对应的源代码映射,以支持源码级别的缓存。
- 更快的热更新速度:通过核心模块分层和按需代码分割,热更新速度得到了提升。

4. **diff 算法优化**

对于 Fragment 的 diff 过程进行了优化,避免了低效的组件选择和更新,同时对于动态组件和移动端的性能进行了显著提升。
具体来说, Vue 3 在新旧两组静态节点一致的场景下,可以完全跳过 diff 算法,直接复用旧的 vnode 树。而且它还会利用静态节点进行优化,
如果一个节点在当前更新中没有更改,那么就可以为它添加一个标记,在下次更新时可以跳过对这些静态节点的 diff 算法。

5. **手动控制渲染时机**

Vue 3 提供了新的手动控制 renderer 的功能,我们可以手动控制渲染的时机,而无需在每一个状态改变后立即重新渲染。
这允许我们在多个状态改变之后,手动地按批处理渲染,从而避免了一些不必要的中间状态的渲染。

6. **按需实现 SSR**

Vue 3 在服务端渲染 (SSR) 的时候,通过分包的方式,实现了真正的按需注入,这使得 SSR bundle 的体积更小,因此加载速度更快。

总的来说,Vue 3 在编译模型、diff 算法、事件监听、SSR 等多个方面进行了优化,从而提高了运行时的性能。
其中,静态提升和静态节点标记优化是最为核心的优化点,可以大幅减少不必要的虚拟DOM重新渲染。
当然,除了性能优化之外,Vue 3 也有诸如 Composition API、Teleport、Fragments 等诸多功能上的加强。
因此,Vue 3 在性能和开发体验上都有了很大的提升。
  */
      /*
 好的,我会按照顺序详细描述一下 Vue 源码中响应式原理从创建到挂载更新的整个过程:

1. **初始化**

在创建 Vue 实例时,会首先初始化一些内部属性,包括事件系统、生命周期、注入的属性等。同时会对传入的 data 选项进行响应式处理,使其变为响应式对象。

2. **创建响应式对象**

当初始化 data 选项时,Vue 会使用 `reactive` 方法将原始对象包裹为一个 Proxy 对象,这个 Proxy 对象就是响应式对象。
每当我们访问或修改响应式对象的属性时,Proxy 都会捕获到并触发相应的操作。

3. **依赖收集**

当我们在渲染函数或计算属性中读取响应式对象的值时,Vue 会自动收集这些依赖。具体来说,Vue 会创建一个 `Dep` 实例,
用来存储所有依赖该属性的"订阅者"(如组件的渲染函数)。

4. **派发更新**

当响应式对象的属性被修改时,Proxy 会通知 Vue 数据已经发生变化。Vue 会依次触发每个受影响的依赖项的重新计算。

5. **更新队列与批量更新**

为了避免同一个事件循环中多次执行昂贵的 DOM 更新操作,Vue 会将这些更新操作缓存到一个队列中,并在下一个事件循环 "tick" 中执行所有更新。
这就实现了批量异步更新。

6. **虚拟 DOM 重新渲染**

当执行批量更新时,Vue 会根据响应式数据的最新状态,重新执行渲染函数,生成新的虚拟 DOM 树。

7. **虚拟 DOM 对比(Diff算法)**

Vue 会比较新旧两个虚拟 DOM 树的差异,找出需要更新的节点,并只更新有差异的部分。这个过程使用了前面提到的高效的 Diff 算法。

8. **渲染更新到真实 DOM**

在完成 Diff 算法计算后,Vue 会根据patch记录,只更新真实 DOM 中发生变化的部分,从而保证最小化的 DOM 操作量。

9. **完成后续工作**
在更新完成后,Vue 还会执行一些清理工作,如触发生命周期钩子、重置依赖收集等。
整个过程是一个循环:数据变化 -> Dep 依赖收集 -> 派发更新 -> 批量更新 -> 虚拟DOM Diff -> 渲染到真实DOM 。当再次修改数据时,这个循环会继续执行。
需要强调的是,这个过程是非阻塞的,即数据更新时不会阻塞当前的执行线程。Vue 利用异步队列的方式,在下一个事件循环中更新视图,从而实现了高效的响应式系统。
总的来说,Vue 响应式系统的工作流程十分高效和优雅,它结合了 Proxy/Object.defineProperty、发布订阅模式、虚拟DOM Diff 等多种技术手段,
构建了一个精妙的响应式数据驱动视图的解决方案。
 
 */

      /*
 在 Vue 源码中,模板编译和数据响应式创建的先后顺序如下:

**1. 模板编译**

在实例化 Vue 对象时,首先会进行模板编译的工作。具体步骤为:

- 解析模板字符串,生成 AST(抽象语法树)
- 优化 AST,标记一些静态节点
- 根据 AST 生成渲染函数字符串

模板编译的结果就是一个渲染函数,它返回一个 VNode 树。这个渲染函数会在后续的数据响应式更新时被调用。

**2. 数据响应式创建**

完成模板编译后,Vue 会对 data 选项进行响应式处理,使其变为响应式对象。具体步骤为:

- 初始化 Vue 实例,设置一些内部属性
- 调用 `initData` 方法,对 data 选项进行响应式处理
  - 使用 `reactive` 方法,基于 Proxy 或 Object.defineProperty 为 data 对象创建响应式代理对象
  - 将响应式数据代理到 Vue 实例上,即 `this.xxx` 可以直接访问响应式数据

在这个过程中,Vue 会收集渲染函数对响应式数据的依赖,以便后续数据变化时可以触发视图更新。

总的来说,Vue 实例化的整个过程可以概括为:

1. 实例初始化
2. 模板编译
   - 解析模板字符串生成 AST
   - 优化 AST
   - 根据 AST 生成渲染函数
3. 数据响应式处理
   - 使用 reactive 方法创建响应式数据对象
   - 收集渲染函数对响应式数据的依赖
4. 实例挂载
   - 渲染函数首次执行,生成初始 VNode 树
   - 将 VNode 树渲染为真实 DOM

之后,在数据发生变化时:

1. 响应式数据被修改,触发依赖更新
2. 重新执行渲染函数,生成新的 VNode 树
3. 使用 Diff 算法对比新旧 VNode 树,记录变更的部分
4. 根据变更的部分,更新真实 DOM

整个过程中,模板编译是在最开始的时候完成的,它的目的是将模板字符串转换为高效的渲染函数。
而数据响应式的创建则是为了构建数据和视图之间的依赖关系,从而在数据变化时可以高效地更新视图。

两者都是 Vue 响应式系统的关键环节,相互配合才能实现"数据驱动视图"的核心功能。
Vue 通过模板编译和响应式系统的结合,实现了高性能、低开销的视图渲染和更新。
 */

      /*
 在 Vue 中,data 选项为一个函数的设计,主要有以下几个原因:

    实现组件数据的独立性

如果将 data 直接写成一个对象的形式,那么同一个组件被复用多次时,它们会共享同一个数据对象,导致数据互相影响。而将 data 设计为一个函数,每次初始化一个组件实例时,都会调用这个函数返回一个全新的数据对象,从而确保多个组件实例的数据是独立、互不影响的。

    方便组件实例的复用

组件设计的初衷就是为了复用,而将 data 设计为函数,可以让每个组件实例维护一份独立的数据副本,避免了由于数据共享导致的潜在问题,有利于提高组件的可复用性。

    更好地支持Vue的响应式原理

Vue 会对 data 函数返回的对象进行响应式处理,以便在数据变化时能够自动触发视图更新。如果 data 是一个原始对象,由于对象是引用类型,多个组件实例共享一个对象会给响应式带来一些额外的复杂性。而函数则很好地规避了这个问题。

    更好地符合 JavaScript 语法习惯

在 JavaScript 中,使用函数来提供可复用的、独立作用域的数据,是一种常见且符合语法习惯的做法。将 data 设计为函数,更符合 JavaScript 语言的理念。

总之,将 data 设计为函数,使得每个组件实例都有自己独立的数据作用域,避免了多个组件实例之间共享数据导致的潜在问题,从而更好地支持组件复用,同时也符合 Vue 的响应式系统设计,以及 JavaScript 语法习惯。这种设计不仅增加了组件的可维护性,也使得 Vue 更加灵活、健壮。
因此,这是一个非常合理且具有前瞻性的设计。
 
 */
    </script>
  </body>
</html>
